/**
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: Cable
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import {Inject, Injectable, Optional} from '@angular/core';
import {HttpClient, HttpEvent, HttpHeaders, HttpParameterCodec, HttpParams, HttpResponse} from '@angular/common/http';
import {CustomHttpParameterCodec} from '../encoder';
import {Observable} from 'rxjs';


import {BASE_PATH, COLLECTION_FORMATS} from '../variables';
import {Configuration} from '../configuration';


@Injectable()
export class DocspublicService {

    protected basePath = 'http://gateway.marvel.com';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key,
                        (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Fetches lists of events filtered by a character id.
     * Fetches lists of events in which a specific character appears, with optional filters. See notes on individual parameters below.
     * @param characterId The character ID.
     * @param name Filter the event list by name.
     * @param nameStartsWith Return events with names that begin with the specified string (e.g. Sp).
     * @param modifiedSince Return only events which have been modified since the specified date.
     * @param creators Return only events which feature work by the specified creators (accepts a comma-separated list of ids).
     * @param series Return only events which are part of the specified series (accepts a comma-separated list of ids).
     * @param comics Return only events which take place in the specified comics (accepts a comma-separated list of ids).
     * @param stories Return only events which contain the specified stories (accepts a comma-separated list of ids).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCharacterEventsCollection(characterId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, creators?: Array<number>, series?: Array<number>, comics?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getCharacterEventsCollection(characterId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, creators?: Array<number>, series?: Array<number>, comics?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getCharacterEventsCollection(characterId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, creators?: Array<number>, series?: Array<number>, comics?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getCharacterEventsCollection(characterId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, creators?: Array<number>, series?: Array<number>, comics?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharacterEventsCollection.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (name !== undefined && name !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>name, 'name');
        }
        if (nameStartsWith !== undefined && nameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>nameStartsWith, 'nameStartsWith');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (creators) {
            queryParameters = this.addToHttpParams(queryParameters,
                creators.join(COLLECTION_FORMATS['csv']), 'creators');
        }
        if (series) {
            queryParameters = this.addToHttpParams(queryParameters,
                series.join(COLLECTION_FORMATS['csv']), 'series');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (stories) {
            queryParameters = this.addToHttpParams(queryParameters,
                stories.join(COLLECTION_FORMATS['csv']), 'stories');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/characters/${encodeURIComponent(String(characterId))}/events`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches a single character by id.
     * This method fetches a single character resource.  It is the canonical URI for any character resource provided by the API.
     * @param characterId A single character id.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCharacterIndividual(characterId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getCharacterIndividual(characterId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getCharacterIndividual(characterId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getCharacterIndividual(characterId: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharacterIndividual.');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/characters/${encodeURIComponent(String(characterId))}`,
            {
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of series filtered by a character id.
     * Fetches lists of comic series in which a specific character appears, with optional filters. See notes on individual parameters below.
     * @param characterId The character ID
     * @param title Filter by series title.
     * @param titleStartsWith Return series with titles that begin with the specified string (e.g. Sp).
     * @param startYear Return only series matching the specified start year.
     * @param modifiedSince Return only series which have been modified since the specified date.
     * @param comics Return only series which contain the specified comics (accepts a comma-separated list of ids).
     * @param stories Return only series which contain the specified stories (accepts a comma-separated list of ids).
     * @param events Return only series which have comics that take place during the specified events (accepts a comma-separated list of ids).
     * @param creators Return only series which feature work by the specified creators (accepts a comma-separated list of ids).
     * @param seriesType Filter the series by publication frequency type.
     * @param contains Return only series containing one or more comics with the specified format.
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCharacterSeriesCollection(characterId: number, title?: string, titleStartsWith?: string, startYear?: number, modifiedSince?: string, comics?: Array<number>, stories?: Array<number>, events?: Array<number>, creators?: Array<number>, seriesType?: 'collection' | 'one shot' | 'limited' | 'ongoing', contains?: Array<string>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getCharacterSeriesCollection(characterId: number, title?: string, titleStartsWith?: string, startYear?: number, modifiedSince?: string, comics?: Array<number>, stories?: Array<number>, events?: Array<number>, creators?: Array<number>, seriesType?: 'collection' | 'one shot' | 'limited' | 'ongoing', contains?: Array<string>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getCharacterSeriesCollection(characterId: number, title?: string, titleStartsWith?: string, startYear?: number, modifiedSince?: string, comics?: Array<number>, stories?: Array<number>, events?: Array<number>, creators?: Array<number>, seriesType?: 'collection' | 'one shot' | 'limited' | 'ongoing', contains?: Array<string>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getCharacterSeriesCollection(characterId: number, title?: string, titleStartsWith?: string, startYear?: number, modifiedSince?: string, comics?: Array<number>, stories?: Array<number>, events?: Array<number>, creators?: Array<number>, seriesType?: 'collection' | 'one shot' | 'limited' | 'ongoing', contains?: Array<string>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharacterSeriesCollection.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (title !== undefined && title !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>title, 'title');
        }
        if (titleStartsWith !== undefined && titleStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>titleStartsWith, 'titleStartsWith');
        }
        if (startYear !== undefined && startYear !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>startYear, 'startYear');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (stories) {
            queryParameters = this.addToHttpParams(queryParameters,
                stories.join(COLLECTION_FORMATS['csv']), 'stories');
        }
        if (events) {
            queryParameters = this.addToHttpParams(queryParameters,
                events.join(COLLECTION_FORMATS['csv']), 'events');
        }
        if (creators) {
            queryParameters = this.addToHttpParams(queryParameters,
                creators.join(COLLECTION_FORMATS['csv']), 'creators');
        }
        if (seriesType !== undefined && seriesType !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>seriesType, 'seriesType');
        }
        if (contains) {
            queryParameters = this.addToHttpParams(queryParameters,
                contains.join(COLLECTION_FORMATS['csv']), 'contains');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/characters/${encodeURIComponent(String(characterId))}/series`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of stories filtered by a character id.
     * Fetches lists of comic stories  featuring a specific character with optional filters. See notes on individual parameters below.
     * @param characterId The character ID.
     * @param modifiedSince Return only stories which have been modified since the specified date.
     * @param comics Return only stories contained in the specified (accepts a comma-separated list of ids).
     * @param series Return only stories contained the specified series (accepts a comma-separated list of ids).
     * @param events Return only stories which take place during the specified events (accepts a comma-separated list of ids).
     * @param creators Return only stories which feature work by the specified creators (accepts a comma-separated list of ids).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCharacterStoryCollection(characterId: number, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, creators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getCharacterStoryCollection(characterId: number, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, creators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getCharacterStoryCollection(characterId: number, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, creators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getCharacterStoryCollection(characterId: number, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, creators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getCharacterStoryCollection.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (series) {
            queryParameters = this.addToHttpParams(queryParameters,
                series.join(COLLECTION_FORMATS['csv']), 'series');
        }
        if (events) {
            queryParameters = this.addToHttpParams(queryParameters,
                events.join(COLLECTION_FORMATS['csv']), 'events');
        }
        if (creators) {
            queryParameters = this.addToHttpParams(queryParameters,
                creators.join(COLLECTION_FORMATS['csv']), 'creators');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/characters/${encodeURIComponent(String(characterId))}/stories`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of characters filtered by a comic id.
     * Fetches lists of characters which appear in a specific comic with optional filters. See notes on individual parameters below.
     * @param comicId The comic id.
     * @param name Return only characters matching the specified full character name (e.g. Spider-Man).
     * @param nameStartsWith Return characters with names that begin with the specified string (e.g. Sp).
     * @param modifiedSince Return only characters which have been modified since the specified date.
     * @param series Return only characters which appear the specified series (accepts a comma-separated list of ids).
     * @param events Return only characters which appear comics that took place in the specified events (accepts a comma-separated list of ids).
     * @param stories Return only characters which appear the specified stories (accepts a comma-separated list of ids).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getComicCharacterCollection(comicId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, series?: Array<number>, events?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getComicCharacterCollection(comicId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, series?: Array<number>, events?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getComicCharacterCollection(comicId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, series?: Array<number>, events?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getComicCharacterCollection(comicId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, series?: Array<number>, events?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (comicId === null || comicId === undefined) {
            throw new Error('Required parameter comicId was null or undefined when calling getComicCharacterCollection.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (name !== undefined && name !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>name, 'name');
        }
        if (nameStartsWith !== undefined && nameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>nameStartsWith, 'nameStartsWith');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (series) {
            queryParameters = this.addToHttpParams(queryParameters,
                series.join(COLLECTION_FORMATS['csv']), 'series');
        }
        if (events) {
            queryParameters = this.addToHttpParams(queryParameters,
                events.join(COLLECTION_FORMATS['csv']), 'events');
        }
        if (stories) {
            queryParameters = this.addToHttpParams(queryParameters,
                stories.join(COLLECTION_FORMATS['csv']), 'stories');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/comics/${encodeURIComponent(String(comicId))}/characters`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches a single comic by id.
     * This method fetches a single comic resource.  It is the canonical URI for any comic resource provided by the API.
     * @param comicId A single comic.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getComicIndividual(comicId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getComicIndividual(comicId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getComicIndividual(comicId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getComicIndividual(comicId: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (comicId === null || comicId === undefined) {
            throw new Error('Required parameter comicId was null or undefined when calling getComicIndividual.');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/comics/${encodeURIComponent(String(comicId))}`,
            {
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of stories filtered by a comic id.
     * Fetches lists of comic stories in a specific comic issue, with optional filters. See notes on individual parameters below.
     * @param comicId The comic ID.
     * @param modifiedSince Return only stories which have been modified since the specified date.
     * @param series Return only stories contained the specified series (accepts a comma-separated list of ids).
     * @param events Return only stories which take place during the specified events (accepts a comma-separated list of ids).
     * @param creators Return only stories which feature work by the specified creators (accepts a comma-separated list of ids).
     * @param characters Return only stories which feature the specified characters (accepts a comma-separated list of ids).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getComicStoryCollection(comicId: number, modifiedSince?: string, series?: Array<number>, events?: Array<number>, creators?: Array<number>, characters?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getComicStoryCollection(comicId: number, modifiedSince?: string, series?: Array<number>, events?: Array<number>, creators?: Array<number>, characters?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getComicStoryCollection(comicId: number, modifiedSince?: string, series?: Array<number>, events?: Array<number>, creators?: Array<number>, characters?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getComicStoryCollection(comicId: number, modifiedSince?: string, series?: Array<number>, events?: Array<number>, creators?: Array<number>, characters?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (comicId === null || comicId === undefined) {
            throw new Error('Required parameter comicId was null or undefined when calling getComicStoryCollection.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (series) {
            queryParameters = this.addToHttpParams(queryParameters,
                series.join(COLLECTION_FORMATS['csv']), 'series');
        }
        if (events) {
            queryParameters = this.addToHttpParams(queryParameters,
                events.join(COLLECTION_FORMATS['csv']), 'events');
        }
        if (creators) {
            queryParameters = this.addToHttpParams(queryParameters,
                creators.join(COLLECTION_FORMATS['csv']), 'creators');
        }
        if (characters) {
            queryParameters = this.addToHttpParams(queryParameters,
                characters.join(COLLECTION_FORMATS['csv']), 'characters');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/comics/${encodeURIComponent(String(comicId))}/stories`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of comics filtered by a character id.
     * Fetches lists of comics containing a specific character, with optional filters. See notes on individual parameters below.
     * @param characterId The character id.
     * @param format Filter by the issue format (e.g. comic, digital comic, hardcover).
     * @param formatType Filter by the issue format type (comic or collection).
     * @param noVariants Exclude variant comics from the result set.
     * @param dateDescriptor Return comics within a predefined date range.
     * @param dateRange Return comics within a predefined date range.  Dates must be specified as date1,date2 (e.g. 2013-01-01,2013-01-02).  Dates are preferably formatted as YYYY-MM-DD but may be sent as any common date format.
     * @param title Return only issues in series whose title matches the input.
     * @param titleStartsWith Return only issues in series whose title starts with the input.
     * @param startYear Return only issues in series whose start year matches the input.
     * @param issueNumber Return only issues in series whose issue number matches the input.
     * @param diamondCode Filter by diamond code.
     * @param digitalId Filter by digital comic id.
     * @param upc Filter by UPC.
     * @param isbn Filter by ISBN.
     * @param ean Filter by EAN.
     * @param issn Filter by ISSN.
     * @param hasDigitalIssue Include only results which are available digitally.
     * @param modifiedSince Return only comics which have been modified since the specified date.
     * @param creators Return only comics which feature work by the specified creators (accepts a comma-separated list of ids).
     * @param series Return only comics which are part of the specified series (accepts a comma-separated list of ids).
     * @param events Return only comics which take place in the specified events (accepts a comma-separated list of ids).
     * @param stories Return only comics which contain the specified stories (accepts a comma-separated list of ids).
     * @param sharedAppearances Return only comics in which the specified characters appear together (for example in which BOTH Spider-Man and Wolverine appear).
     * @param collaborators Return only comics in which the specified creators worked together (for example in which BOTH Stan Lee and Jack Kirby did work).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getComicsCharacterCollection(characterId: number, format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: boolean, dateDescriptor?: 'lastWeek' | 'thisWeek' | 'nextWeek' | 'thisMonth', dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: boolean, modifiedSince?: string, creators?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getComicsCharacterCollection(characterId: number, format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: boolean, dateDescriptor?: 'lastWeek' | 'thisWeek' | 'nextWeek' | 'thisMonth', dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: boolean, modifiedSince?: string, creators?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getComicsCharacterCollection(characterId: number, format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: boolean, dateDescriptor?: 'lastWeek' | 'thisWeek' | 'nextWeek' | 'thisMonth', dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: boolean, modifiedSince?: string, creators?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getComicsCharacterCollection(characterId: number, format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: boolean, dateDescriptor?: 'lastWeek' | 'thisWeek' | 'nextWeek' | 'thisMonth', dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: boolean, modifiedSince?: string, creators?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (characterId === null || characterId === undefined) {
            throw new Error('Required parameter characterId was null or undefined when calling getComicsCharacterCollection.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (format !== undefined && format !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>format, 'format');
        }
        if (formatType !== undefined && formatType !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>formatType, 'formatType');
        }
        if (noVariants !== undefined && noVariants !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>noVariants, 'noVariants');
        }
        if (dateDescriptor !== undefined && dateDescriptor !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>dateDescriptor, 'dateDescriptor');
        }
        if (dateRange) {
            queryParameters = this.addToHttpParams(queryParameters,
                dateRange.join(COLLECTION_FORMATS['csv']), 'dateRange');
        }
        if (title !== undefined && title !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>title, 'title');
        }
        if (titleStartsWith !== undefined && titleStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>titleStartsWith, 'titleStartsWith');
        }
        if (startYear !== undefined && startYear !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>startYear, 'startYear');
        }
        if (issueNumber !== undefined && issueNumber !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>issueNumber, 'issueNumber');
        }
        if (diamondCode !== undefined && diamondCode !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>diamondCode, 'diamondCode');
        }
        if (digitalId !== undefined && digitalId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>digitalId, 'digitalId');
        }
        if (upc !== undefined && upc !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>upc, 'upc');
        }
        if (isbn !== undefined && isbn !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>isbn, 'isbn');
        }
        if (ean !== undefined && ean !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>ean, 'ean');
        }
        if (issn !== undefined && issn !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>issn, 'issn');
        }
        if (hasDigitalIssue !== undefined && hasDigitalIssue !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>hasDigitalIssue, 'hasDigitalIssue');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (creators) {
            queryParameters = this.addToHttpParams(queryParameters,
                creators.join(COLLECTION_FORMATS['csv']), 'creators');
        }
        if (series) {
            queryParameters = this.addToHttpParams(queryParameters,
                series.join(COLLECTION_FORMATS['csv']), 'series');
        }
        if (events) {
            queryParameters = this.addToHttpParams(queryParameters,
                events.join(COLLECTION_FORMATS['csv']), 'events');
        }
        if (stories) {
            queryParameters = this.addToHttpParams(queryParameters,
                stories.join(COLLECTION_FORMATS['csv']), 'stories');
        }
        if (sharedAppearances) {
            queryParameters = this.addToHttpParams(queryParameters,
                sharedAppearances.join(COLLECTION_FORMATS['csv']), 'sharedAppearances');
        }
        if (collaborators) {
            queryParameters = this.addToHttpParams(queryParameters,
                collaborators.join(COLLECTION_FORMATS['csv']), 'collaborators');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/characters/${encodeURIComponent(String(characterId))}/comics`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of comics filtered by a creator id.
     * Fetches lists of comics in which the work of a specific creator appears, with optional filters. See notes on individual parameters below.
     * @param creatorId The creator ID.
     * @param format Filter by the issue format (e.g. comic, digital comic, hardcover).
     * @param formatType Filter by the issue format type (comic or collection).
     * @param noVariants Exclude variant comics from the result set.
     * @param dateDescriptor Return comics within a predefined date range.
     * @param dateRange Return comics within a predefined date range.  Dates must be specified as date1,date2 (e.g. 2013-01-01,2013-01-02).  Dates are preferably formatted as YYYY-MM-DD but may be sent as any common date format.
     * @param title Return only issues in series whose title matches the input.
     * @param titleStartsWith Return only issues in series whose title starts with the input.
     * @param startYear Return only issues in series whose start year matches the input.
     * @param issueNumber Return only issues in series whose issue number matches the input.
     * @param diamondCode Filter by diamond code.
     * @param digitalId Filter by digital comic id.
     * @param upc Filter by UPC.
     * @param isbn Filter by ISBN.
     * @param ean Filter by EAN.
     * @param issn Filter by ISSN.
     * @param hasDigitalIssue Include only results which are available digitally.
     * @param modifiedSince Return only comics which have been modified since the specified date.
     * @param characters Return only comics which feature the specified characters (accepts a comma-separated list of ids).
     * @param series Return only comics which are part of the specified series (accepts a comma-separated list of ids).
     * @param events Return only comics which take place in the specified events (accepts a comma-separated list of ids).
     * @param stories Return only comics which contain the specified stories (accepts a comma-separated list of ids).
     * @param sharedAppearances Return only comics in which the specified characters appear together (for example in which BOTH Spider-Man and Wolverine appear).
     * @param collaborators Return only comics in which the specified creators worked together (for example in which BOTH Stan Lee and Jack Kirby did work).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getComicsCollection(creatorId: number, format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: boolean, dateDescriptor?: 'lastWeek' | 'thisWeek' | 'nextWeek' | 'thisMonth', dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: Array<boolean>, modifiedSince?: string, characters?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getComicsCollection(creatorId: number, format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: boolean, dateDescriptor?: 'lastWeek' | 'thisWeek' | 'nextWeek' | 'thisMonth', dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: Array<boolean>, modifiedSince?: string, characters?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getComicsCollection(creatorId: number, format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: boolean, dateDescriptor?: 'lastWeek' | 'thisWeek' | 'nextWeek' | 'thisMonth', dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: Array<boolean>, modifiedSince?: string, characters?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getComicsCollection(creatorId: number, format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: boolean, dateDescriptor?: 'lastWeek' | 'thisWeek' | 'nextWeek' | 'thisMonth', dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: Array<boolean>, modifiedSince?: string, characters?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (creatorId === null || creatorId === undefined) {
            throw new Error('Required parameter creatorId was null or undefined when calling getComicsCollection.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (format !== undefined && format !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>format, 'format');
        }
        if (formatType !== undefined && formatType !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>formatType, 'formatType');
        }
        if (noVariants !== undefined && noVariants !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>noVariants, 'noVariants');
        }
        if (dateDescriptor !== undefined && dateDescriptor !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>dateDescriptor, 'dateDescriptor');
        }
        if (dateRange) {
            queryParameters = this.addToHttpParams(queryParameters,
                dateRange.join(COLLECTION_FORMATS['csv']), 'dateRange');
        }
        if (title !== undefined && title !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>title, 'title');
        }
        if (titleStartsWith !== undefined && titleStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>titleStartsWith, 'titleStartsWith');
        }
        if (startYear !== undefined && startYear !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>startYear, 'startYear');
        }
        if (issueNumber !== undefined && issueNumber !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>issueNumber, 'issueNumber');
        }
        if (diamondCode !== undefined && diamondCode !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>diamondCode, 'diamondCode');
        }
        if (digitalId !== undefined && digitalId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>digitalId, 'digitalId');
        }
        if (upc !== undefined && upc !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>upc, 'upc');
        }
        if (isbn !== undefined && isbn !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>isbn, 'isbn');
        }
        if (ean !== undefined && ean !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>ean, 'ean');
        }
        if (issn !== undefined && issn !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>issn, 'issn');
        }
        if (hasDigitalIssue) {
            queryParameters = this.addToHttpParams(queryParameters,
                hasDigitalIssue.join(COLLECTION_FORMATS['csv']), 'hasDigitalIssue');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (characters) {
            queryParameters = this.addToHttpParams(queryParameters,
                characters.join(COLLECTION_FORMATS['csv']), 'characters');
        }
        if (series) {
            queryParameters = this.addToHttpParams(queryParameters,
                series.join(COLLECTION_FORMATS['csv']), 'series');
        }
        if (events) {
            queryParameters = this.addToHttpParams(queryParameters,
                events.join(COLLECTION_FORMATS['csv']), 'events');
        }
        if (stories) {
            queryParameters = this.addToHttpParams(queryParameters,
                stories.join(COLLECTION_FORMATS['csv']), 'stories');
        }
        if (sharedAppearances) {
            queryParameters = this.addToHttpParams(queryParameters,
                sharedAppearances.join(COLLECTION_FORMATS['csv']), 'sharedAppearances');
        }
        if (collaborators) {
            queryParameters = this.addToHttpParams(queryParameters,
                collaborators.join(COLLECTION_FORMATS['csv']), 'collaborators');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/creators/${encodeURIComponent(String(creatorId))}/comics`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of comics filtered by an event id.
     * Fetches lists of comics which take place during a specific event, with optional filters. See notes on individual parameters below.
     * @param eventId The event id.
     * @param format Filter by the issue format (e.g. comic, digital comic, hardcover).
     * @param formatType Filter by the issue format type (comic or collection).
     * @param noVariants Exclude variant comics from the result set.
     * @param dateDescriptor Return comics within a predefined date range.
     * @param dateRange Return comics within a predefined date range.  Dates must be specified as date1,date2 (e.g. 2013-01-01,2013-01-02).  Dates are preferably formatted as YYYY-MM-DD but may be sent as any common date format.
     * @param title Return only issues in series whose title matches the input.
     * @param titleStartsWith Return only issues in series whose title starts with the input.
     * @param startYear Return only issues in series whose start year matches the input.
     * @param issueNumber Return only issues in series whose issue number matches the input.
     * @param diamondCode Filter by diamond code.
     * @param digitalId Filter by digital comic id.
     * @param upc Filter by UPC.
     * @param isbn Filter by ISBN.
     * @param ean Filter by EAN.
     * @param issn Filter by ISSN.
     * @param hasDigitalIssue Include only results which are available digitally.
     * @param modifiedSince Return only comics which have been modified since the specified date.
     * @param creators Return only comics which feature work by the specified creators (accepts a comma-separated list of ids).
     * @param characters Return only comics which feature the specified characters (accepts a comma-separated list of ids).
     * @param series Return only comics which are part of the specified series (accepts a comma-separated list of ids).
     * @param events Return only comics which take place in the specified events (accepts a comma-separated list of ids).
     * @param stories Return only comics which contain the specified stories (accepts a comma-separated list of ids).
     * @param sharedAppearances Return only comics in which the specified characters appear together (for example in which BOTH Spider-Man and Wolverine appear).
     * @param collaborators Return only comics in which the specified creators worked together (for example in which BOTH Stan Lee and Jack Kirby did work).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getComicsCollection_1(eventId: number, format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: Array<boolean>, dateDescriptor?: Array<string>, dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: Array<boolean>, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getComicsCollection_1(eventId: number, format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: Array<boolean>, dateDescriptor?: Array<string>, dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: Array<boolean>, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getComicsCollection_1(eventId: number, format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: Array<boolean>, dateDescriptor?: Array<string>, dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: Array<boolean>, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getComicsCollection_1(eventId: number, format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: Array<boolean>, dateDescriptor?: Array<string>, dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: Array<boolean>, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling getComicsCollection_1.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (format !== undefined && format !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>format, 'format');
        }
        if (formatType !== undefined && formatType !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>formatType, 'formatType');
        }
        if (noVariants) {
            queryParameters = this.addToHttpParams(queryParameters,
                noVariants.join(COLLECTION_FORMATS['csv']), 'noVariants');
        }
        if (dateDescriptor) {
            queryParameters = this.addToHttpParams(queryParameters,
                dateDescriptor.join(COLLECTION_FORMATS['csv']), 'dateDescriptor');
        }
        if (dateRange) {
            queryParameters = this.addToHttpParams(queryParameters,
                dateRange.join(COLLECTION_FORMATS['csv']), 'dateRange');
        }
        if (title !== undefined && title !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>title, 'title');
        }
        if (titleStartsWith !== undefined && titleStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>titleStartsWith, 'titleStartsWith');
        }
        if (startYear !== undefined && startYear !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>startYear, 'startYear');
        }
        if (issueNumber !== undefined && issueNumber !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>issueNumber, 'issueNumber');
        }
        if (diamondCode !== undefined && diamondCode !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>diamondCode, 'diamondCode');
        }
        if (digitalId !== undefined && digitalId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>digitalId, 'digitalId');
        }
        if (upc !== undefined && upc !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>upc, 'upc');
        }
        if (isbn !== undefined && isbn !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>isbn, 'isbn');
        }
        if (ean !== undefined && ean !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>ean, 'ean');
        }
        if (issn !== undefined && issn !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>issn, 'issn');
        }
        if (hasDigitalIssue) {
            queryParameters = this.addToHttpParams(queryParameters,
                hasDigitalIssue.join(COLLECTION_FORMATS['csv']), 'hasDigitalIssue');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (creators) {
            queryParameters = this.addToHttpParams(queryParameters,
                creators.join(COLLECTION_FORMATS['csv']), 'creators');
        }
        if (characters) {
            queryParameters = this.addToHttpParams(queryParameters,
                characters.join(COLLECTION_FORMATS['csv']), 'characters');
        }
        if (series) {
            queryParameters = this.addToHttpParams(queryParameters,
                series.join(COLLECTION_FORMATS['csv']), 'series');
        }
        if (events) {
            queryParameters = this.addToHttpParams(queryParameters,
                events.join(COLLECTION_FORMATS['csv']), 'events');
        }
        if (stories) {
            queryParameters = this.addToHttpParams(queryParameters,
                stories.join(COLLECTION_FORMATS['csv']), 'stories');
        }
        if (sharedAppearances) {
            queryParameters = this.addToHttpParams(queryParameters,
                sharedAppearances.join(COLLECTION_FORMATS['csv']), 'sharedAppearances');
        }
        if (collaborators) {
            queryParameters = this.addToHttpParams(queryParameters,
                collaborators.join(COLLECTION_FORMATS['csv']), 'collaborators');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/events/${encodeURIComponent(String(eventId))}/comics`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of comics filtered by a series id.
     * Fetches lists of comics which are published as part of a specific series, with optional filters. See notes on individual parameters below.
     * @param seriesId The series ID.
     * @param format Filter by the issue format (e.g. comic, digital comic, hardcover).
     * @param formatType Filter by the issue format type (comic or collection).
     * @param noVariants Exclude variant comics from the result set.
     * @param dateDescriptor Return comics within a predefined date range.
     * @param dateRange Return comics within a predefined date range.  Dates must be specified as date1,date2 (e.g. 2013-01-01,2013-01-02).  Dates are preferably formatted as YYYY-MM-DD but may be sent as any common date format.
     * @param title Return only issues in series whose title matches the input.
     * @param titleStartsWith Return only issues in series whose title starts with the input.
     * @param startYear Return only issues in series whose start year matches the input.
     * @param issueNumber Return only issues in series whose issue number matches the input.
     * @param diamondCode Filter by diamond code.
     * @param digitalId Filter by digital comic id.
     * @param upc Filter by UPC.
     * @param isbn Filter by ISBN.
     * @param ean Filter by EAN.
     * @param issn Filter by ISSN.
     * @param hasDigitalIssue Include only results which are available digitally.
     * @param modifiedSince Return only comics which have been modified since the specified date.
     * @param creators Return only comics which feature work by the specified creators (accepts a comma-separated list of ids).
     * @param characters Return only comics which feature the specified characters (accepts a comma-separated list of ids).
     * @param events Return only comics which take place in the specified events (accepts a comma-separated list of ids).
     * @param stories Return only comics which contain the specified stories (accepts a comma-separated list of ids).
     * @param sharedAppearances Return only comics in which the specified characters appear together (for example in which BOTH Spider-Man and Wolverine appear).
     * @param collaborators Return only comics in which the specified creators worked together (for example in which BOTH Stan Lee and Jack Kirby did work).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getComicsCollection_2(seriesId: number, format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: Array<boolean>, dateDescriptor?: Array<string>, dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: Array<boolean>, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, events?: Array<number>, stories?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getComicsCollection_2(seriesId: number, format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: Array<boolean>, dateDescriptor?: Array<string>, dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: Array<boolean>, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, events?: Array<number>, stories?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getComicsCollection_2(seriesId: number, format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: Array<boolean>, dateDescriptor?: Array<string>, dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: Array<boolean>, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, events?: Array<number>, stories?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getComicsCollection_2(seriesId: number, format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: Array<boolean>, dateDescriptor?: Array<string>, dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: Array<boolean>, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, events?: Array<number>, stories?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (seriesId === null || seriesId === undefined) {
            throw new Error('Required parameter seriesId was null or undefined when calling getComicsCollection_2.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (format !== undefined && format !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>format, 'format');
        }
        if (formatType !== undefined && formatType !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>formatType, 'formatType');
        }
        if (noVariants) {
            queryParameters = this.addToHttpParams(queryParameters,
                noVariants.join(COLLECTION_FORMATS['csv']), 'noVariants');
        }
        if (dateDescriptor) {
            queryParameters = this.addToHttpParams(queryParameters,
                dateDescriptor.join(COLLECTION_FORMATS['csv']), 'dateDescriptor');
        }
        if (dateRange) {
            queryParameters = this.addToHttpParams(queryParameters,
                dateRange.join(COLLECTION_FORMATS['csv']), 'dateRange');
        }
        if (title !== undefined && title !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>title, 'title');
        }
        if (titleStartsWith !== undefined && titleStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>titleStartsWith, 'titleStartsWith');
        }
        if (startYear !== undefined && startYear !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>startYear, 'startYear');
        }
        if (issueNumber !== undefined && issueNumber !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>issueNumber, 'issueNumber');
        }
        if (diamondCode !== undefined && diamondCode !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>diamondCode, 'diamondCode');
        }
        if (digitalId !== undefined && digitalId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>digitalId, 'digitalId');
        }
        if (upc !== undefined && upc !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>upc, 'upc');
        }
        if (isbn !== undefined && isbn !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>isbn, 'isbn');
        }
        if (ean !== undefined && ean !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>ean, 'ean');
        }
        if (issn !== undefined && issn !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>issn, 'issn');
        }
        if (hasDigitalIssue) {
            queryParameters = this.addToHttpParams(queryParameters,
                hasDigitalIssue.join(COLLECTION_FORMATS['csv']), 'hasDigitalIssue');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (creators) {
            queryParameters = this.addToHttpParams(queryParameters,
                creators.join(COLLECTION_FORMATS['csv']), 'creators');
        }
        if (characters) {
            queryParameters = this.addToHttpParams(queryParameters,
                characters.join(COLLECTION_FORMATS['csv']), 'characters');
        }
        if (events) {
            queryParameters = this.addToHttpParams(queryParameters,
                events.join(COLLECTION_FORMATS['csv']), 'events');
        }
        if (stories) {
            queryParameters = this.addToHttpParams(queryParameters,
                stories.join(COLLECTION_FORMATS['csv']), 'stories');
        }
        if (sharedAppearances) {
            queryParameters = this.addToHttpParams(queryParameters,
                sharedAppearances.join(COLLECTION_FORMATS['csv']), 'sharedAppearances');
        }
        if (collaborators) {
            queryParameters = this.addToHttpParams(queryParameters,
                collaborators.join(COLLECTION_FORMATS['csv']), 'collaborators');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/series/${encodeURIComponent(String(seriesId))}/comics`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of comics.
     * Fetches lists of comics with optional filters. See notes on individual parameters below.
     * @param format Filter by the issue format (e.g. comic, digital comic, hardcover).
     * @param formatType Filter by the issue format type (comic or collection).
     * @param noVariants Exclude variants (alternate covers, secondary printings, director\&#39;s cuts, etc.) from the result set.
     * @param dateDescriptor Return comics within a predefined date range.
     * @param dateRange Return comics within a predefined date range.  Dates must be specified as date1,date2 (e.g. 2013-01-01,2013-01-02).  Dates are preferably formatted as YYYY-MM-DD but may be sent as any common date format.
     * @param title Return only issues in series whose title matches the input.
     * @param titleStartsWith Return only issues in series whose title starts with the input.
     * @param startYear Return only issues in series whose start year matches the input.
     * @param issueNumber Return only issues in series whose issue number matches the input.
     * @param diamondCode Filter by diamond code.
     * @param digitalId Filter by digital comic id.
     * @param upc Filter by UPC.
     * @param isbn Filter by ISBN.
     * @param ean Filter by EAN.
     * @param issn Filter by ISSN.
     * @param hasDigitalIssue Include only results which are available digitally.
     * @param modifiedSince Return only comics which have been modified since the specified date.
     * @param creators Return only comics which feature work by the specified creators (accepts a comma-separated list of ids).
     * @param characters Return only comics which feature the specified characters (accepts a comma-separated list of ids).
     * @param series Return only comics which are part of the specified series (accepts a comma-separated list of ids).
     * @param events Return only comics which take place in the specified events (accepts a comma-separated list of ids).
     * @param stories Return only comics which contain the specified stories (accepts a comma-separated list of ids).
     * @param sharedAppearances Return only comics in which the specified characters appear together (for example in which BOTH Spider-Man and Wolverine appear). Accepts a comma-separated list of ids.
     * @param collaborators Return only comics in which the specified creators worked together (for example in which BOTH Stan Lee and Jack Kirby did work). Accepts a comma-separated list of ids.
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getComicsCollection_3(format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: boolean, dateDescriptor?: 'lastWeek' | 'thisWeek' | 'nextWeek' | 'thisMonth', dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: boolean, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getComicsCollection_3(format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: boolean, dateDescriptor?: 'lastWeek' | 'thisWeek' | 'nextWeek' | 'thisMonth', dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: boolean, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getComicsCollection_3(format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: boolean, dateDescriptor?: 'lastWeek' | 'thisWeek' | 'nextWeek' | 'thisMonth', dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: boolean, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getComicsCollection_3(format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: boolean, dateDescriptor?: 'lastWeek' | 'thisWeek' | 'nextWeek' | 'thisMonth', dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: boolean, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (format !== undefined && format !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>format, 'format');
        }
        if (formatType !== undefined && formatType !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>formatType, 'formatType');
        }
        if (noVariants !== undefined && noVariants !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>noVariants, 'noVariants');
        }
        if (dateDescriptor !== undefined && dateDescriptor !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>dateDescriptor, 'dateDescriptor');
        }
        if (dateRange) {
            queryParameters = this.addToHttpParams(queryParameters,
                dateRange.join(COLLECTION_FORMATS['csv']), 'dateRange');
        }
        if (title !== undefined && title !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>title, 'title');
        }
        if (titleStartsWith !== undefined && titleStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>titleStartsWith, 'titleStartsWith');
        }
        if (startYear !== undefined && startYear !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>startYear, 'startYear');
        }
        if (issueNumber !== undefined && issueNumber !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>issueNumber, 'issueNumber');
        }
        if (diamondCode !== undefined && diamondCode !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>diamondCode, 'diamondCode');
        }
        if (digitalId !== undefined && digitalId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>digitalId, 'digitalId');
        }
        if (upc !== undefined && upc !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>upc, 'upc');
        }
        if (isbn !== undefined && isbn !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>isbn, 'isbn');
        }
        if (ean !== undefined && ean !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>ean, 'ean');
        }
        if (issn !== undefined && issn !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>issn, 'issn');
        }
        if (hasDigitalIssue !== undefined && hasDigitalIssue !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>hasDigitalIssue, 'hasDigitalIssue');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (creators) {
            queryParameters = this.addToHttpParams(queryParameters,
                creators.join(COLLECTION_FORMATS['csv']), 'creators');
        }
        if (characters) {
            queryParameters = this.addToHttpParams(queryParameters,
                characters.join(COLLECTION_FORMATS['csv']), 'characters');
        }
        if (series) {
            queryParameters = this.addToHttpParams(queryParameters,
                series.join(COLLECTION_FORMATS['csv']), 'series');
        }
        if (events) {
            queryParameters = this.addToHttpParams(queryParameters,
                events.join(COLLECTION_FORMATS['csv']), 'events');
        }
        if (stories) {
            queryParameters = this.addToHttpParams(queryParameters,
                stories.join(COLLECTION_FORMATS['csv']), 'stories');
        }
        if (sharedAppearances) {
            queryParameters = this.addToHttpParams(queryParameters,
                sharedAppearances.join(COLLECTION_FORMATS['csv']), 'sharedAppearances');
        }
        if (collaborators) {
            queryParameters = this.addToHttpParams(queryParameters,
                collaborators.join(COLLECTION_FORMATS['csv']), 'collaborators');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/comics`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of comics filtered by a story id.
     * Fetches lists of comics in which a specific story appears, with optional filters. See notes on individual parameters below.
     * @param storyId The story ID.
     * @param format Filter by the issue format (e.g. comic, digital comic, hardcover).
     * @param formatType Filter by the issue format type (comic or collection).
     * @param noVariants Exclude variant comics from the result set.
     * @param dateDescriptor Return comics within a predefined date range.
     * @param dateRange Return comics within a predefined date range.  Dates must be specified as date1,date2 (e.g. 2013-01-01,2013-01-02).  Dates are preferably formatted as YYYY-MM-DD but may be sent as any common date format.
     * @param title Return only issues in series whose title matches the input.
     * @param titleStartsWith Return only issues in series whose title starts with the input.
     * @param startYear Return only issues in series whose start year matches the input.
     * @param issueNumber Return only issues in series whose issue number matches the input.
     * @param diamondCode Filter by diamond code.
     * @param digitalId Filter by digital comic id.
     * @param upc Filter by UPC.
     * @param isbn Filter by ISBN.
     * @param ean Filter by EAN.
     * @param issn Filter by ISSN.
     * @param hasDigitalIssue Include only results which are available digitally.
     * @param modifiedSince Return only comics which have been modified since the specified date.
     * @param creators Return only comics which feature work by the specified creators (accepts a comma-separated list of ids).
     * @param characters Return only comics which feature the specified characters (accepts a comma-separated list of ids).
     * @param series Return only comics which are part of the specified series (accepts a comma-separated list of ids).
     * @param events Return only comics which take place in the specified events (accepts a comma-separated list of ids).
     * @param sharedAppearances Return only comics in which the specified characters appear together (for example in which BOTH Spider-Man and Wolverine appear).
     * @param collaborators Return only comics in which the specified creators worked together (for example in which BOTH Stan Lee and Jack Kirby did work).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getComicsCollection_4(storyId: number, format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: Array<boolean>, dateDescriptor?: Array<string>, dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: Array<boolean>, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, events?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getComicsCollection_4(storyId: number, format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: Array<boolean>, dateDescriptor?: Array<string>, dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: Array<boolean>, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, events?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getComicsCollection_4(storyId: number, format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: Array<boolean>, dateDescriptor?: Array<string>, dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: Array<boolean>, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, events?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getComicsCollection_4(storyId: number, format?: 'comic' | 'magazine' | 'trade paperback' | 'hardcover' | 'digest' | 'graphic novel' | 'digital comic' | 'infinite comic', formatType?: 'comic' | 'collection', noVariants?: Array<boolean>, dateDescriptor?: Array<string>, dateRange?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, issueNumber?: number, diamondCode?: string, digitalId?: number, upc?: string, isbn?: string, ean?: string, issn?: string, hasDigitalIssue?: Array<boolean>, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, events?: Array<number>, sharedAppearances?: Array<number>, collaborators?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (storyId === null || storyId === undefined) {
            throw new Error('Required parameter storyId was null or undefined when calling getComicsCollection_4.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (format !== undefined && format !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>format, 'format');
        }
        if (formatType !== undefined && formatType !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>formatType, 'formatType');
        }
        if (noVariants) {
            queryParameters = this.addToHttpParams(queryParameters,
                noVariants.join(COLLECTION_FORMATS['csv']), 'noVariants');
        }
        if (dateDescriptor) {
            queryParameters = this.addToHttpParams(queryParameters,
                dateDescriptor.join(COLLECTION_FORMATS['csv']), 'dateDescriptor');
        }
        if (dateRange) {
            queryParameters = this.addToHttpParams(queryParameters,
                dateRange.join(COLLECTION_FORMATS['csv']), 'dateRange');
        }
        if (title !== undefined && title !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>title, 'title');
        }
        if (titleStartsWith !== undefined && titleStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>titleStartsWith, 'titleStartsWith');
        }
        if (startYear !== undefined && startYear !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>startYear, 'startYear');
        }
        if (issueNumber !== undefined && issueNumber !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>issueNumber, 'issueNumber');
        }
        if (diamondCode !== undefined && diamondCode !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>diamondCode, 'diamondCode');
        }
        if (digitalId !== undefined && digitalId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>digitalId, 'digitalId');
        }
        if (upc !== undefined && upc !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>upc, 'upc');
        }
        if (isbn !== undefined && isbn !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>isbn, 'isbn');
        }
        if (ean !== undefined && ean !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>ean, 'ean');
        }
        if (issn !== undefined && issn !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>issn, 'issn');
        }
        if (hasDigitalIssue) {
            queryParameters = this.addToHttpParams(queryParameters,
                hasDigitalIssue.join(COLLECTION_FORMATS['csv']), 'hasDigitalIssue');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (creators) {
            queryParameters = this.addToHttpParams(queryParameters,
                creators.join(COLLECTION_FORMATS['csv']), 'creators');
        }
        if (characters) {
            queryParameters = this.addToHttpParams(queryParameters,
                characters.join(COLLECTION_FORMATS['csv']), 'characters');
        }
        if (series) {
            queryParameters = this.addToHttpParams(queryParameters,
                series.join(COLLECTION_FORMATS['csv']), 'series');
        }
        if (events) {
            queryParameters = this.addToHttpParams(queryParameters,
                events.join(COLLECTION_FORMATS['csv']), 'events');
        }
        if (sharedAppearances) {
            queryParameters = this.addToHttpParams(queryParameters,
                sharedAppearances.join(COLLECTION_FORMATS['csv']), 'sharedAppearances');
        }
        if (collaborators) {
            queryParameters = this.addToHttpParams(queryParameters,
                collaborators.join(COLLECTION_FORMATS['csv']), 'collaborators');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/stories/${encodeURIComponent(String(storyId))}/comics`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of creators.
     * Fetches lists of comic creators with optional filters. See notes on individual parameters below.
     * @param firstName Filter by creator first name (e.g. Brian).
     * @param middleName Filter by creator middle name (e.g. Michael).
     * @param lastName Filter by creator last name (e.g. Bendis).
     * @param suffix Filter by suffix or honorific (e.g. Jr., Sr.).
     * @param nameStartsWith Filter by creator names that match critera (e.g. B, St L).
     * @param firstNameStartsWith Filter by creator first names that match critera (e.g. B, St L).
     * @param middleNameStartsWith Filter by creator middle names that match critera (e.g. Mi).
     * @param lastNameStartsWith Filter by creator last names that match critera (e.g. Ben).
     * @param modifiedSince Return only creators which have been modified since the specified date.
     * @param comics Return only creators who worked on in the specified comics (accepts a comma-separated list of ids).
     * @param series Return only creators who worked on the specified series (accepts a comma-separated list of ids).
     * @param events Return only creators who worked on comics that took place in the specified events (accepts a comma-separated list of ids).
     * @param stories Return only creators who worked on the specified stories (accepts a comma-separated list of ids).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCreatorCollection(firstName?: string, middleName?: string, lastName?: string, suffix?: string, nameStartsWith?: string, firstNameStartsWith?: string, middleNameStartsWith?: string, lastNameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getCreatorCollection(firstName?: string, middleName?: string, lastName?: string, suffix?: string, nameStartsWith?: string, firstNameStartsWith?: string, middleNameStartsWith?: string, lastNameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getCreatorCollection(firstName?: string, middleName?: string, lastName?: string, suffix?: string, nameStartsWith?: string, firstNameStartsWith?: string, middleNameStartsWith?: string, lastNameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getCreatorCollection(firstName?: string, middleName?: string, lastName?: string, suffix?: string, nameStartsWith?: string, firstNameStartsWith?: string, middleNameStartsWith?: string, lastNameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (firstName !== undefined && firstName !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>firstName, 'firstName');
        }
        if (middleName !== undefined && middleName !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>middleName, 'middleName');
        }
        if (lastName !== undefined && lastName !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>lastName, 'lastName');
        }
        if (suffix !== undefined && suffix !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>suffix, 'suffix');
        }
        if (nameStartsWith !== undefined && nameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>nameStartsWith, 'nameStartsWith');
        }
        if (firstNameStartsWith !== undefined && firstNameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>firstNameStartsWith, 'firstNameStartsWith');
        }
        if (middleNameStartsWith !== undefined && middleNameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>middleNameStartsWith, 'middleNameStartsWith');
        }
        if (lastNameStartsWith !== undefined && lastNameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>lastNameStartsWith, 'lastNameStartsWith');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (series) {
            queryParameters = this.addToHttpParams(queryParameters,
                series.join(COLLECTION_FORMATS['csv']), 'series');
        }
        if (events) {
            queryParameters = this.addToHttpParams(queryParameters,
                events.join(COLLECTION_FORMATS['csv']), 'events');
        }
        if (stories) {
            queryParameters = this.addToHttpParams(queryParameters,
                stories.join(COLLECTION_FORMATS['csv']), 'stories');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/creators`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of characters filtered by a story id.
     * Fetches lists of comic characters appearing in a single story, with optional filters. See notes on individual parameters below.
     * @param storyId The story ID.
     * @param name Return only characters matching the specified full character name (e.g. Spider-Man).
     * @param nameStartsWith Return characters with names that begin with the specified string (e.g. Sp).
     * @param modifiedSince Return only characters which have been modified since the specified date.
     * @param comics Return only characters which appear in the specified comics (accepts a comma-separated list of ids).
     * @param series Return only characters which appear the specified series (accepts a comma-separated list of ids).
     * @param events Return only characters which appear comics that took place in the specified events (accepts a comma-separated list of ids).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCreatorCollection_5(storyId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getCreatorCollection_5(storyId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getCreatorCollection_5(storyId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getCreatorCollection_5(storyId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (storyId === null || storyId === undefined) {
            throw new Error('Required parameter storyId was null or undefined when calling getCreatorCollection_5.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (name !== undefined && name !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>name, 'name');
        }
        if (nameStartsWith !== undefined && nameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>nameStartsWith, 'nameStartsWith');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (series) {
            queryParameters = this.addToHttpParams(queryParameters,
                series.join(COLLECTION_FORMATS['csv']), 'series');
        }
        if (events) {
            queryParameters = this.addToHttpParams(queryParameters,
                events.join(COLLECTION_FORMATS['csv']), 'events');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/stories/${encodeURIComponent(String(storyId))}/characters`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of creators filtered by a series id.
     * Fetches lists of comic creators whose work appears in a specific series, with optional filters. See notes on individual parameters below.
     * @param seriesId The series ID.
     * @param firstName Filter by creator first name (e.g. brian).
     * @param middleName Filter by creator middle name (e.g. Michael).
     * @param lastName Filter by creator last name (e.g. Bendis).
     * @param suffix Filter by suffix or honorific (e.g. Jr., Sr.).
     * @param nameStartsWith Filter by creator names that match critera (e.g. B, St L).
     * @param firstNameStartsWith Filter by creator first names that match critera (e.g. B, St L).
     * @param middleNameStartsWith Filter by creator middle names that match critera (e.g. Mi).
     * @param lastNameStartsWith Filter by creator last names that match critera (e.g. Ben).
     * @param modifiedSince Return only creators which have been modified since the specified date.
     * @param comics Return only creators who worked on in the specified comics (accepts a comma-separated list of ids).
     * @param events Return only creators who worked on comics that took place in the specified events (accepts a comma-separated list of ids).
     * @param stories Return only creators who worked on the specified stories (accepts a comma-separated list of ids).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCreatorCollection_6(seriesId: number, firstName?: string, middleName?: string, lastName?: string, suffix?: string, nameStartsWith?: string, firstNameStartsWith?: string, middleNameStartsWith?: string, lastNameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, events?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getCreatorCollection_6(seriesId: number, firstName?: string, middleName?: string, lastName?: string, suffix?: string, nameStartsWith?: string, firstNameStartsWith?: string, middleNameStartsWith?: string, lastNameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, events?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getCreatorCollection_6(seriesId: number, firstName?: string, middleName?: string, lastName?: string, suffix?: string, nameStartsWith?: string, firstNameStartsWith?: string, middleNameStartsWith?: string, lastNameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, events?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getCreatorCollection_6(seriesId: number, firstName?: string, middleName?: string, lastName?: string, suffix?: string, nameStartsWith?: string, firstNameStartsWith?: string, middleNameStartsWith?: string, lastNameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, events?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (seriesId === null || seriesId === undefined) {
            throw new Error('Required parameter seriesId was null or undefined when calling getCreatorCollection_6.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (firstName !== undefined && firstName !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>firstName, 'firstName');
        }
        if (middleName !== undefined && middleName !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>middleName, 'middleName');
        }
        if (lastName !== undefined && lastName !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>lastName, 'lastName');
        }
        if (suffix !== undefined && suffix !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>suffix, 'suffix');
        }
        if (nameStartsWith !== undefined && nameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>nameStartsWith, 'nameStartsWith');
        }
        if (firstNameStartsWith !== undefined && firstNameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>firstNameStartsWith, 'firstNameStartsWith');
        }
        if (middleNameStartsWith !== undefined && middleNameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>middleNameStartsWith, 'middleNameStartsWith');
        }
        if (lastNameStartsWith !== undefined && lastNameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>lastNameStartsWith, 'lastNameStartsWith');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (events) {
            queryParameters = this.addToHttpParams(queryParameters,
                events.join(COLLECTION_FORMATS['csv']), 'events');
        }
        if (stories) {
            queryParameters = this.addToHttpParams(queryParameters,
                stories.join(COLLECTION_FORMATS['csv']), 'stories');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/series/${encodeURIComponent(String(seriesId))}/creators`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of creators filtered by a comic id.
     * Fetches lists of comic creators whose work appears in a specific comic, with optional filters. See notes on individual parameters below.
     * @param comicId The comic id.
     * @param firstName Filter by creator first name (e.g. brian).
     * @param middleName Filter by creator middle name (e.g. Michael).
     * @param lastName Filter by creator last name (e.g. Bendis).
     * @param suffix Filter by suffix or honorific (e.g. Jr., Sr.).
     * @param nameStartsWith Filter by creator names that match critera (e.g. B, St L).
     * @param firstNameStartsWith Filter by creator first names that match critera (e.g. B, St L).
     * @param middleNameStartsWith Filter by creator middle names that match critera (e.g. Mi).
     * @param lastNameStartsWith Filter by creator last names that match critera (e.g. Ben).
     * @param modifiedSince Return only creators which have been modified since the specified date.
     * @param comics Return only creators who worked on in the specified comics (accepts a comma-separated list of ids).
     * @param series Return only creators who worked on the specified series (accepts a comma-separated list of ids).
     * @param stories Return only creators who worked on the specified stories (accepts a comma-separated list of ids).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCreatorCollection_7(comicId: number, firstName?: string, middleName?: string, lastName?: string, suffix?: string, nameStartsWith?: string, firstNameStartsWith?: string, middleNameStartsWith?: string, lastNameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getCreatorCollection_7(comicId: number, firstName?: string, middleName?: string, lastName?: string, suffix?: string, nameStartsWith?: string, firstNameStartsWith?: string, middleNameStartsWith?: string, lastNameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getCreatorCollection_7(comicId: number, firstName?: string, middleName?: string, lastName?: string, suffix?: string, nameStartsWith?: string, firstNameStartsWith?: string, middleNameStartsWith?: string, lastNameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getCreatorCollection_7(comicId: number, firstName?: string, middleName?: string, lastName?: string, suffix?: string, nameStartsWith?: string, firstNameStartsWith?: string, middleNameStartsWith?: string, lastNameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (comicId === null || comicId === undefined) {
            throw new Error('Required parameter comicId was null or undefined when calling getCreatorCollection_7.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (firstName !== undefined && firstName !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>firstName, 'firstName');
        }
        if (middleName !== undefined && middleName !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>middleName, 'middleName');
        }
        if (lastName !== undefined && lastName !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>lastName, 'lastName');
        }
        if (suffix !== undefined && suffix !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>suffix, 'suffix');
        }
        if (nameStartsWith !== undefined && nameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>nameStartsWith, 'nameStartsWith');
        }
        if (firstNameStartsWith !== undefined && firstNameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>firstNameStartsWith, 'firstNameStartsWith');
        }
        if (middleNameStartsWith !== undefined && middleNameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>middleNameStartsWith, 'middleNameStartsWith');
        }
        if (lastNameStartsWith !== undefined && lastNameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>lastNameStartsWith, 'lastNameStartsWith');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (series) {
            queryParameters = this.addToHttpParams(queryParameters,
                series.join(COLLECTION_FORMATS['csv']), 'series');
        }
        if (stories) {
            queryParameters = this.addToHttpParams(queryParameters,
                stories.join(COLLECTION_FORMATS['csv']), 'stories');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/comics/${encodeURIComponent(String(comicId))}/creators`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of characters.
     * Fetches lists of comic characters with optional filters. See notes on individual parameters below.
     * @param name Return only characters matching the specified full character name (e.g. Spider-Man).
     * @param nameStartsWith Return characters with names that begin with the specified string (e.g. Sp).
     * @param modifiedSince Return only characters which have been modified since the specified date.
     * @param comics Return only characters which appear in the specified comics (accepts a comma-separated list of ids).
     * @param series Return only characters which appear the specified series (accepts a comma-separated list of ids).
     * @param events Return only characters which appear in the specified events (accepts a comma-separated list of ids).
     * @param stories Return only characters which appear the specified stories (accepts a comma-separated list of ids).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCreatorCollection_8(name?: string, nameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getCreatorCollection_8(name?: string, nameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getCreatorCollection_8(name?: string, nameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getCreatorCollection_8(name?: string, nameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (name !== undefined && name !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>name, 'name');
        }
        if (nameStartsWith !== undefined && nameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>nameStartsWith, 'nameStartsWith');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (series) {
            queryParameters = this.addToHttpParams(queryParameters,
                series.join(COLLECTION_FORMATS['csv']), 'series');
        }
        if (events) {
            queryParameters = this.addToHttpParams(queryParameters,
                events.join(COLLECTION_FORMATS['csv']), 'events');
        }
        if (stories) {
            queryParameters = this.addToHttpParams(queryParameters,
                stories.join(COLLECTION_FORMATS['csv']), 'stories');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/characters`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of creators filtered by a story id.
     * Fetches lists of comic creators whose work appears in a specific story, with optional filters. See notes on individual parameters below.
     * @param storyId The story ID.
     * @param firstName Filter by creator first name (e.g. brian).
     * @param middleName Filter by creator middle name (e.g. Michael).
     * @param lastName Filter by creator last name (e.g. Bendis).
     * @param suffix Filter by suffix or honorific (e.g. Jr., Sr.).
     * @param nameStartsWith Filter by creator names that match critera (e.g. B, St L).
     * @param firstNameStartsWith Filter by creator first names that match critera (e.g. B, St L).
     * @param middleNameStartsWith Filter by creator middle names that match critera (e.g. Mi).
     * @param lastNameStartsWith Filter by creator last names that match critera (e.g. Ben).
     * @param modifiedSince Return only creators which have been modified since the specified date.
     * @param comics Return only creators who worked on in the specified comics (accepts a comma-separated list of ids).
     * @param series Return only creators who worked on the specified series (accepts a comma-separated list of ids).
     * @param events Return only creators who worked on comics that took place in the specified events (accepts a comma-separated list of ids).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCreatorCollection_9(storyId: number, firstName?: string, middleName?: string, lastName?: string, suffix?: string, nameStartsWith?: string, firstNameStartsWith?: string, middleNameStartsWith?: string, lastNameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getCreatorCollection_9(storyId: number, firstName?: string, middleName?: string, lastName?: string, suffix?: string, nameStartsWith?: string, firstNameStartsWith?: string, middleNameStartsWith?: string, lastNameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getCreatorCollection_9(storyId: number, firstName?: string, middleName?: string, lastName?: string, suffix?: string, nameStartsWith?: string, firstNameStartsWith?: string, middleNameStartsWith?: string, lastNameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getCreatorCollection_9(storyId: number, firstName?: string, middleName?: string, lastName?: string, suffix?: string, nameStartsWith?: string, firstNameStartsWith?: string, middleNameStartsWith?: string, lastNameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (storyId === null || storyId === undefined) {
            throw new Error('Required parameter storyId was null or undefined when calling getCreatorCollection_9.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (firstName !== undefined && firstName !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>firstName, 'firstName');
        }
        if (middleName !== undefined && middleName !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>middleName, 'middleName');
        }
        if (lastName !== undefined && lastName !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>lastName, 'lastName');
        }
        if (suffix !== undefined && suffix !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>suffix, 'suffix');
        }
        if (nameStartsWith !== undefined && nameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>nameStartsWith, 'nameStartsWith');
        }
        if (firstNameStartsWith !== undefined && firstNameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>firstNameStartsWith, 'firstNameStartsWith');
        }
        if (middleNameStartsWith !== undefined && middleNameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>middleNameStartsWith, 'middleNameStartsWith');
        }
        if (lastNameStartsWith !== undefined && lastNameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>lastNameStartsWith, 'lastNameStartsWith');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (series) {
            queryParameters = this.addToHttpParams(queryParameters,
                series.join(COLLECTION_FORMATS['csv']), 'series');
        }
        if (events) {
            queryParameters = this.addToHttpParams(queryParameters,
                events.join(COLLECTION_FORMATS['csv']), 'events');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/stories/${encodeURIComponent(String(storyId))}/creators`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of creators filtered by an event id.
     * Fetches lists of comic creators whose work appears in a specific event, with optional filters. See notes on individual parameters below.
     * @param eventId The event ID.
     * @param firstName Filter by creator first name (e.g. brian).
     * @param middleName Filter by creator middle name (e.g. Michael).
     * @param lastName Filter by creator last name (e.g. Bendis).
     * @param suffix Filter by suffix or honorific (e.g. Jr., Sr.).
     * @param nameStartsWith Filter by creator names that match critera (e.g. B, St L).
     * @param firstNameStartsWith Filter by creator first names that match critera (e.g. B, St L).
     * @param middleNameStartsWith Filter by creator middle names that match critera (e.g. Mi).
     * @param lastNameStartsWith Filter by creator last names that match critera (e.g. Ben).
     * @param modifiedSince Return only creators which have been modified since the specified date.
     * @param comics Return only creators who worked on in the specified comics (accepts a comma-separated list of ids).
     * @param series Return only creators who worked on the specified series (accepts a comma-separated list of ids).
     * @param stories Return only creators who worked on the specified stories (accepts a comma-separated list of ids).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCreatorCollection_10(eventId: number, firstName?: string, middleName?: string, lastName?: string, suffix?: string, nameStartsWith?: string, firstNameStartsWith?: string, middleNameStartsWith?: string, lastNameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getCreatorCollection_10(eventId: number, firstName?: string, middleName?: string, lastName?: string, suffix?: string, nameStartsWith?: string, firstNameStartsWith?: string, middleNameStartsWith?: string, lastNameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getCreatorCollection_10(eventId: number, firstName?: string, middleName?: string, lastName?: string, suffix?: string, nameStartsWith?: string, firstNameStartsWith?: string, middleNameStartsWith?: string, lastNameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getCreatorCollection_10(eventId: number, firstName?: string, middleName?: string, lastName?: string, suffix?: string, nameStartsWith?: string, firstNameStartsWith?: string, middleNameStartsWith?: string, lastNameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling getCreatorCollection_10.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (firstName !== undefined && firstName !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>firstName, 'firstName');
        }
        if (middleName !== undefined && middleName !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>middleName, 'middleName');
        }
        if (lastName !== undefined && lastName !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>lastName, 'lastName');
        }
        if (suffix !== undefined && suffix !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>suffix, 'suffix');
        }
        if (nameStartsWith !== undefined && nameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>nameStartsWith, 'nameStartsWith');
        }
        if (firstNameStartsWith !== undefined && firstNameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>firstNameStartsWith, 'firstNameStartsWith');
        }
        if (middleNameStartsWith !== undefined && middleNameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>middleNameStartsWith, 'middleNameStartsWith');
        }
        if (lastNameStartsWith !== undefined && lastNameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>lastNameStartsWith, 'lastNameStartsWith');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (series) {
            queryParameters = this.addToHttpParams(queryParameters,
                series.join(COLLECTION_FORMATS['csv']), 'series');
        }
        if (stories) {
            queryParameters = this.addToHttpParams(queryParameters,
                stories.join(COLLECTION_FORMATS['csv']), 'stories');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/events/${encodeURIComponent(String(eventId))}/creators`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of events filtered by a creator id.
     * Fetches lists of events featuring the work of a specific creator with optional filters. See notes on individual parameters below.
     * @param creatorId The creator ID.
     * @param name Filter the event list by name.
     * @param nameStartsWith Return events with names that begin with the specified string (e.g. Sp).
     * @param modifiedSince Return only events which have been modified since the specified date.
     * @param characters Return only events which feature the specified characters (accepts a comma-separated list of ids).
     * @param series Return only events which are part of the specified series (accepts a comma-separated list of ids).
     * @param comics Return only events which take place in the specified comics (accepts a comma-separated list of ids).
     * @param stories Return only events which contain the specified stories (accepts a comma-separated list of ids).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCreatorEventsCollection(creatorId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, characters?: Array<number>, series?: Array<number>, comics?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getCreatorEventsCollection(creatorId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, characters?: Array<number>, series?: Array<number>, comics?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getCreatorEventsCollection(creatorId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, characters?: Array<number>, series?: Array<number>, comics?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getCreatorEventsCollection(creatorId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, characters?: Array<number>, series?: Array<number>, comics?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (creatorId === null || creatorId === undefined) {
            throw new Error('Required parameter creatorId was null or undefined when calling getCreatorEventsCollection.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (name !== undefined && name !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>name, 'name');
        }
        if (nameStartsWith !== undefined && nameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>nameStartsWith, 'nameStartsWith');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (characters) {
            queryParameters = this.addToHttpParams(queryParameters,
                characters.join(COLLECTION_FORMATS['csv']), 'characters');
        }
        if (series) {
            queryParameters = this.addToHttpParams(queryParameters,
                series.join(COLLECTION_FORMATS['csv']), 'series');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (stories) {
            queryParameters = this.addToHttpParams(queryParameters,
                stories.join(COLLECTION_FORMATS['csv']), 'stories');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/creators/${encodeURIComponent(String(creatorId))}/events`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches a single creator by id.
     * This method fetches a single creator resource.  It is the canonical URI for any creator resource provided by the API.
     * @param creatorId A single creator id.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCreatorIndividual(creatorId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getCreatorIndividual(creatorId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getCreatorIndividual(creatorId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getCreatorIndividual(creatorId: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (creatorId === null || creatorId === undefined) {
            throw new Error('Required parameter creatorId was null or undefined when calling getCreatorIndividual.');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/creators/${encodeURIComponent(String(creatorId))}`,
            {
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of series filtered by a creator id.
     * Fetches lists of comic series in which a specific creator\&#39;s work appears, with optional filters. See notes on individual parameters below.
     * @param creatorId The creator ID.
     * @param title Filter by series title.
     * @param titleStartsWith Return series with titles that begin with the specified string (e.g. Sp).
     * @param startYear Return only series matching the specified start year.
     * @param modifiedSince Return only series which have been modified since the specified date.
     * @param comics Return only series which contain the specified comics (accepts a comma-separated list of ids).
     * @param stories Return only series which contain the specified stories (accepts a comma-separated list of ids).
     * @param events Return only series which have comics that take place during the specified events (accepts a comma-separated list of ids).
     * @param characters Return only series which feature the specified characters (accepts a comma-separated list of ids).
     * @param seriesType Filter the series by publication frequency type.
     * @param contains Return only series containing one or more comics with the specified format.
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCreatorSeriesCollection(creatorId: number, title?: string, titleStartsWith?: string, startYear?: number, modifiedSince?: string, comics?: Array<number>, stories?: Array<number>, events?: Array<number>, characters?: Array<number>, seriesType?: 'collection' | 'one shot' | 'limited' | 'ongoing', contains?: Array<string>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getCreatorSeriesCollection(creatorId: number, title?: string, titleStartsWith?: string, startYear?: number, modifiedSince?: string, comics?: Array<number>, stories?: Array<number>, events?: Array<number>, characters?: Array<number>, seriesType?: 'collection' | 'one shot' | 'limited' | 'ongoing', contains?: Array<string>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getCreatorSeriesCollection(creatorId: number, title?: string, titleStartsWith?: string, startYear?: number, modifiedSince?: string, comics?: Array<number>, stories?: Array<number>, events?: Array<number>, characters?: Array<number>, seriesType?: 'collection' | 'one shot' | 'limited' | 'ongoing', contains?: Array<string>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getCreatorSeriesCollection(creatorId: number, title?: string, titleStartsWith?: string, startYear?: number, modifiedSince?: string, comics?: Array<number>, stories?: Array<number>, events?: Array<number>, characters?: Array<number>, seriesType?: 'collection' | 'one shot' | 'limited' | 'ongoing', contains?: Array<string>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (creatorId === null || creatorId === undefined) {
            throw new Error('Required parameter creatorId was null or undefined when calling getCreatorSeriesCollection.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (title !== undefined && title !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>title, 'title');
        }
        if (titleStartsWith !== undefined && titleStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>titleStartsWith, 'titleStartsWith');
        }
        if (startYear !== undefined && startYear !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>startYear, 'startYear');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (stories) {
            queryParameters = this.addToHttpParams(queryParameters,
                stories.join(COLLECTION_FORMATS['csv']), 'stories');
        }
        if (events) {
            queryParameters = this.addToHttpParams(queryParameters,
                events.join(COLLECTION_FORMATS['csv']), 'events');
        }
        if (characters) {
            queryParameters = this.addToHttpParams(queryParameters,
                characters.join(COLLECTION_FORMATS['csv']), 'characters');
        }
        if (seriesType !== undefined && seriesType !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>seriesType, 'seriesType');
        }
        if (contains) {
            queryParameters = this.addToHttpParams(queryParameters,
                contains.join(COLLECTION_FORMATS['csv']), 'contains');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/creators/${encodeURIComponent(String(creatorId))}/series`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of stories filtered by a creator id.
     * Fetches lists of comic stories by a specific creator with optional filters. See notes on individual parameters below.
     * @param creatorId The ID of the creator.
     * @param modifiedSince Return only stories which have been modified since the specified date.
     * @param comics Return only stories contained in the specified comics (accepts a comma-separated list of ids).
     * @param series Return only stories contained the specified series (accepts a comma-separated list of ids).
     * @param events Return only stories which take place during the specified events (accepts a comma-separated list of ids).
     * @param characters Return only stories which feature the specified characters (accepts a comma-separated list of ids).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCreatorStoryCollection(creatorId: number, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, characters?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getCreatorStoryCollection(creatorId: number, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, characters?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getCreatorStoryCollection(creatorId: number, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, characters?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getCreatorStoryCollection(creatorId: number, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, characters?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (creatorId === null || creatorId === undefined) {
            throw new Error('Required parameter creatorId was null or undefined when calling getCreatorStoryCollection.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (series) {
            queryParameters = this.addToHttpParams(queryParameters,
                series.join(COLLECTION_FORMATS['csv']), 'series');
        }
        if (events) {
            queryParameters = this.addToHttpParams(queryParameters,
                events.join(COLLECTION_FORMATS['csv']), 'events');
        }
        if (characters) {
            queryParameters = this.addToHttpParams(queryParameters,
                characters.join(COLLECTION_FORMATS['csv']), 'characters');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/creators/${encodeURIComponent(String(creatorId))}/stories`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of characters filtered by an event id.
     * Fetches lists of characters which appear in a specific event, with optional filters. See notes on individual parameters below.
     * @param eventId The event ID
     * @param name Return only characters matching the specified full character name (e.g. Spider-Man).
     * @param nameStartsWith Return characters with names that begin with the specified string (e.g. Sp).
     * @param modifiedSince Return only characters which have been modified since the specified date.
     * @param comics Return only characters which appear in the specified comics (accepts a comma-separated list of ids).
     * @param series Return only characters which appear the specified series (accepts a comma-separated list of ids).
     * @param stories Return only characters which appear the specified stories (accepts a comma-separated list of ids).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEventCharacterCollection(eventId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getEventCharacterCollection(eventId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getEventCharacterCollection(eventId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getEventCharacterCollection(eventId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling getEventCharacterCollection.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (name !== undefined && name !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>name, 'name');
        }
        if (nameStartsWith !== undefined && nameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>nameStartsWith, 'nameStartsWith');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (series) {
            queryParameters = this.addToHttpParams(queryParameters,
                series.join(COLLECTION_FORMATS['csv']), 'series');
        }
        if (stories) {
            queryParameters = this.addToHttpParams(queryParameters,
                stories.join(COLLECTION_FORMATS['csv']), 'stories');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/events/${encodeURIComponent(String(eventId))}/characters`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches a single event by id.
     * This method fetches a single event resource.  It is the canonical URI for any event resource provided by the API.
     * @param eventId A single event.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEventIndividual(eventId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getEventIndividual(eventId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getEventIndividual(eventId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getEventIndividual(eventId: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling getEventIndividual.');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/events/${encodeURIComponent(String(eventId))}`,
            {
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of series filtered by an event id.
     * Fetches lists of comic series in which a specific event takes place, with optional filters. See notes on individual parameters below.
     * @param eventId The event ID.
     * @param title Filter by series title.
     * @param titleStartsWith Return series with titles that begin with the specified string (e.g. Sp).
     * @param startYear Return only series matching the specified start year.
     * @param modifiedSince Return only series which have been modified since the specified date.
     * @param comics Return only series which contain the specified comics (accepts a comma-separated list of ids).
     * @param stories Return only series which contain the specified stories (accepts a comma-separated list of ids).
     * @param creators Return only series which feature work by the specified creators (accepts a comma-separated list of ids).
     * @param characters Return only series which feature the specified characters (accepts a comma-separated list of ids).
     * @param seriesType Filter the series by publication frequency type.
     * @param contains Return only series containing one or more comics with the specified format.
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEventSeriesCollection(eventId: number, title?: string, titleStartsWith?: string, startYear?: number, modifiedSince?: string, comics?: Array<number>, stories?: Array<number>, creators?: Array<number>, characters?: Array<number>, seriesType?: 'collection' | 'one shot' | 'limited' | 'ongoing', contains?: Array<string>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getEventSeriesCollection(eventId: number, title?: string, titleStartsWith?: string, startYear?: number, modifiedSince?: string, comics?: Array<number>, stories?: Array<number>, creators?: Array<number>, characters?: Array<number>, seriesType?: 'collection' | 'one shot' | 'limited' | 'ongoing', contains?: Array<string>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getEventSeriesCollection(eventId: number, title?: string, titleStartsWith?: string, startYear?: number, modifiedSince?: string, comics?: Array<number>, stories?: Array<number>, creators?: Array<number>, characters?: Array<number>, seriesType?: 'collection' | 'one shot' | 'limited' | 'ongoing', contains?: Array<string>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getEventSeriesCollection(eventId: number, title?: string, titleStartsWith?: string, startYear?: number, modifiedSince?: string, comics?: Array<number>, stories?: Array<number>, creators?: Array<number>, characters?: Array<number>, seriesType?: 'collection' | 'one shot' | 'limited' | 'ongoing', contains?: Array<string>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling getEventSeriesCollection.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (title !== undefined && title !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>title, 'title');
        }
        if (titleStartsWith !== undefined && titleStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>titleStartsWith, 'titleStartsWith');
        }
        if (startYear !== undefined && startYear !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>startYear, 'startYear');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (stories) {
            queryParameters = this.addToHttpParams(queryParameters,
                stories.join(COLLECTION_FORMATS['csv']), 'stories');
        }
        if (creators) {
            queryParameters = this.addToHttpParams(queryParameters,
                creators.join(COLLECTION_FORMATS['csv']), 'creators');
        }
        if (characters) {
            queryParameters = this.addToHttpParams(queryParameters,
                characters.join(COLLECTION_FORMATS['csv']), 'characters');
        }
        if (seriesType !== undefined && seriesType !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>seriesType, 'seriesType');
        }
        if (contains) {
            queryParameters = this.addToHttpParams(queryParameters,
                contains.join(COLLECTION_FORMATS['csv']), 'contains');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/events/${encodeURIComponent(String(eventId))}/series`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of stories filtered by an event id.
     * Fetches lists of comic stories from a specific event, with optional filters. See notes on individual parameters below.
     * @param eventId The ID of the event.
     * @param modifiedSince Return only stories which have been modified since the specified date.
     * @param comics Return only stories contained in the specified (accepts a comma-separated list of ids).
     * @param series Return only stories contained the specified series (accepts a comma-separated list of ids).
     * @param creators Return only stories which feature work by the specified creators (accepts a comma-separated list of ids).
     * @param characters Return only stories which feature the specified characters (accepts a comma-separated list of ids).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEventStoryCollection(eventId: number, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, creators?: Array<number>, characters?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getEventStoryCollection(eventId: number, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, creators?: Array<number>, characters?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getEventStoryCollection(eventId: number, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, creators?: Array<number>, characters?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getEventStoryCollection(eventId: number, modifiedSince?: string, comics?: Array<number>, series?: Array<number>, creators?: Array<number>, characters?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling getEventStoryCollection.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (series) {
            queryParameters = this.addToHttpParams(queryParameters,
                series.join(COLLECTION_FORMATS['csv']), 'series');
        }
        if (creators) {
            queryParameters = this.addToHttpParams(queryParameters,
                creators.join(COLLECTION_FORMATS['csv']), 'creators');
        }
        if (characters) {
            queryParameters = this.addToHttpParams(queryParameters,
                characters.join(COLLECTION_FORMATS['csv']), 'characters');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/events/${encodeURIComponent(String(eventId))}/stories`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of events filtered by a story id.
     * Fetches lists of events in which a specific story appears, with optional filters. See notes on individual parameters below.
     * @param storyId The story ID.
     * @param name Filter the event list by name.
     * @param nameStartsWith Return events with names that begin with the specified string (e.g. Sp).
     * @param modifiedSince Return only events which have been modified since the specified date.
     * @param creators Return only events which feature work by the specified creators (accepts a comma-separated list of ids).
     * @param characters Return only events which feature the specified characters (accepts a comma-separated list of ids).
     * @param series Return only events which are part of the specified series (accepts a comma-separated list of ids).
     * @param comics Return only events which take place in the specified comics (accepts a comma-separated list of ids).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEventsCollection(storyId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, comics?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getEventsCollection(storyId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, comics?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getEventsCollection(storyId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, comics?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getEventsCollection(storyId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, comics?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (storyId === null || storyId === undefined) {
            throw new Error('Required parameter storyId was null or undefined when calling getEventsCollection.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (name !== undefined && name !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>name, 'name');
        }
        if (nameStartsWith !== undefined && nameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>nameStartsWith, 'nameStartsWith');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (creators) {
            queryParameters = this.addToHttpParams(queryParameters,
                creators.join(COLLECTION_FORMATS['csv']), 'creators');
        }
        if (characters) {
            queryParameters = this.addToHttpParams(queryParameters,
                characters.join(COLLECTION_FORMATS['csv']), 'characters');
        }
        if (series) {
            queryParameters = this.addToHttpParams(queryParameters,
                series.join(COLLECTION_FORMATS['csv']), 'series');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/stories/${encodeURIComponent(String(storyId))}/events`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of events filtered by a series id.
     * Fetches lists of events which occur in a specific series, with optional filters. See notes on individual parameters below.
     * @param seriesId The series ID.
     * @param name Filter the event list by name.
     * @param nameStartsWith Return events with names that begin with the specified string (e.g. Sp).
     * @param modifiedSince Return only events which have been modified since the specified date.
     * @param creators Return only events which feature work by the specified creators (accepts a comma-separated list of ids).
     * @param characters Return only events which feature the specified characters (accepts a comma-separated list of ids).
     * @param comics Return only events which take place in the specified comics (accepts a comma-separated list of ids).
     * @param stories Return only events which contain the specified stories (accepts a comma-separated list of ids).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEventsCollection_11(seriesId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, comics?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getEventsCollection_11(seriesId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, comics?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getEventsCollection_11(seriesId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, comics?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getEventsCollection_11(seriesId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, comics?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (seriesId === null || seriesId === undefined) {
            throw new Error('Required parameter seriesId was null or undefined when calling getEventsCollection_11.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (name !== undefined && name !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>name, 'name');
        }
        if (nameStartsWith !== undefined && nameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>nameStartsWith, 'nameStartsWith');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (creators) {
            queryParameters = this.addToHttpParams(queryParameters,
                creators.join(COLLECTION_FORMATS['csv']), 'creators');
        }
        if (characters) {
            queryParameters = this.addToHttpParams(queryParameters,
                characters.join(COLLECTION_FORMATS['csv']), 'characters');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (stories) {
            queryParameters = this.addToHttpParams(queryParameters,
                stories.join(COLLECTION_FORMATS['csv']), 'stories');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/series/${encodeURIComponent(String(seriesId))}/events`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of events.
     * Fetches lists of events with optional filters. See notes on individual parameters below.
     * @param name Return only events which match the specified name.
     * @param nameStartsWith Return events with names that begin with the specified string (e.g. Sp).
     * @param modifiedSince Return only events which have been modified since the specified date.
     * @param creators Return only events which feature work by the specified creators (accepts a comma-separated list of ids).
     * @param characters Return only events which feature the specified characters (accepts a comma-separated list of ids).
     * @param series Return only events which are part of the specified series (accepts a comma-separated list of ids).
     * @param comics Return only events which take place in the specified comics (accepts a comma-separated list of ids).
     * @param stories Return only events which take place in the specified stories (accepts a comma-separated list of ids).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEventsCollection_12(name?: string, nameStartsWith?: string, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, comics?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getEventsCollection_12(name?: string, nameStartsWith?: string, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, comics?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getEventsCollection_12(name?: string, nameStartsWith?: string, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, comics?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getEventsCollection_12(name?: string, nameStartsWith?: string, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, comics?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (name !== undefined && name !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>name, 'name');
        }
        if (nameStartsWith !== undefined && nameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>nameStartsWith, 'nameStartsWith');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (creators) {
            queryParameters = this.addToHttpParams(queryParameters,
                creators.join(COLLECTION_FORMATS['csv']), 'creators');
        }
        if (characters) {
            queryParameters = this.addToHttpParams(queryParameters,
                characters.join(COLLECTION_FORMATS['csv']), 'characters');
        }
        if (series) {
            queryParameters = this.addToHttpParams(queryParameters,
                series.join(COLLECTION_FORMATS['csv']), 'series');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (stories) {
            queryParameters = this.addToHttpParams(queryParameters,
                stories.join(COLLECTION_FORMATS['csv']), 'stories');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/events`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of events filtered by a comic id.
     * Fetches lists of events in which a specific comic appears, with optional filters. See notes on individual parameters below.
     * @param comicId The comic ID.
     * @param name Filter the event list by name.
     * @param nameStartsWith Return events with names that begin with the specified string (e.g. Sp).
     * @param modifiedSince Return only events which have been modified since the specified date.
     * @param creators Return only events which feature work by the specified creators (accepts a comma-separated list of ids).
     * @param characters Return only events which feature the specified characters (accepts a comma-separated list of ids).
     * @param series Return only events which are part of the specified series (accepts a comma-separated list of ids).
     * @param stories Return only events which contain the specified stories (accepts a comma-separated list of ids).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getIssueEventsCollection(comicId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getIssueEventsCollection(comicId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getIssueEventsCollection(comicId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getIssueEventsCollection(comicId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, creators?: Array<number>, characters?: Array<number>, series?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (comicId === null || comicId === undefined) {
            throw new Error('Required parameter comicId was null or undefined when calling getIssueEventsCollection.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (name !== undefined && name !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>name, 'name');
        }
        if (nameStartsWith !== undefined && nameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>nameStartsWith, 'nameStartsWith');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (creators) {
            queryParameters = this.addToHttpParams(queryParameters,
                creators.join(COLLECTION_FORMATS['csv']), 'creators');
        }
        if (characters) {
            queryParameters = this.addToHttpParams(queryParameters,
                characters.join(COLLECTION_FORMATS['csv']), 'characters');
        }
        if (series) {
            queryParameters = this.addToHttpParams(queryParameters,
                series.join(COLLECTION_FORMATS['csv']), 'series');
        }
        if (stories) {
            queryParameters = this.addToHttpParams(queryParameters,
                stories.join(COLLECTION_FORMATS['csv']), 'stories');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/comics/${encodeURIComponent(String(comicId))}/events`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of characters filtered by a series id.
     * Fetches lists of characters which appear in specific series, with optional filters. See notes on individual parameters below.
     * @param seriesId The series id.
     * @param name Return only characters matching the specified full character name (e.g. Spider-Man).
     * @param nameStartsWith Return characters with names that begin with the specified string (e.g. Sp).
     * @param modifiedSince Return only characters which have been modified since the specified date.
     * @param comics Return only characters which appear in the specified comics (accepts a comma-separated list of ids).
     * @param events Return only characters which appear comics that took place in the specified events (accepts a comma-separated list of ids).
     * @param stories Return only characters which appear the specified stories (accepts a comma-separated list of ids).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSeriesCharacterWrapper(seriesId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, events?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getSeriesCharacterWrapper(seriesId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, events?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getSeriesCharacterWrapper(seriesId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, events?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getSeriesCharacterWrapper(seriesId: number, name?: string, nameStartsWith?: string, modifiedSince?: string, comics?: Array<number>, events?: Array<number>, stories?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (seriesId === null || seriesId === undefined) {
            throw new Error('Required parameter seriesId was null or undefined when calling getSeriesCharacterWrapper.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (name !== undefined && name !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>name, 'name');
        }
        if (nameStartsWith !== undefined && nameStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>nameStartsWith, 'nameStartsWith');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (events) {
            queryParameters = this.addToHttpParams(queryParameters,
                events.join(COLLECTION_FORMATS['csv']), 'events');
        }
        if (stories) {
            queryParameters = this.addToHttpParams(queryParameters,
                stories.join(COLLECTION_FORMATS['csv']), 'stories');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/series/${encodeURIComponent(String(seriesId))}/characters`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of series.
     * Fetches lists of comic series with optional filters. See notes on individual parameters below.
     * @param title Return only series matching the specified title.
     * @param titleStartsWith Return series with titles that begin with the specified string (e.g. Sp).
     * @param startYear Return only series matching the specified start year.
     * @param modifiedSince Return only series which have been modified since the specified date.
     * @param comics Return only series which contain the specified comics (accepts a comma-separated list of ids).
     * @param stories Return only series which contain the specified stories (accepts a comma-separated list of ids).
     * @param events Return only series which have comics that take place during the specified events (accepts a comma-separated list of ids).
     * @param creators Return only series which feature work by the specified creators (accepts a comma-separated list of ids).
     * @param characters Return only series which feature the specified characters (accepts a comma-separated list of ids).
     * @param seriesType Filter the series by publication frequency type.
     * @param contains Return only series containing one or more comics with the specified format.
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSeriesCollection(title?: string, titleStartsWith?: string, startYear?: number, modifiedSince?: string, comics?: Array<number>, stories?: Array<number>, events?: Array<number>, creators?: Array<number>, characters?: Array<number>, seriesType?: 'collection' | 'one shot' | 'limited' | 'ongoing', contains?: Array<string>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getSeriesCollection(title?: string, titleStartsWith?: string, startYear?: number, modifiedSince?: string, comics?: Array<number>, stories?: Array<number>, events?: Array<number>, creators?: Array<number>, characters?: Array<number>, seriesType?: 'collection' | 'one shot' | 'limited' | 'ongoing', contains?: Array<string>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getSeriesCollection(title?: string, titleStartsWith?: string, startYear?: number, modifiedSince?: string, comics?: Array<number>, stories?: Array<number>, events?: Array<number>, creators?: Array<number>, characters?: Array<number>, seriesType?: 'collection' | 'one shot' | 'limited' | 'ongoing', contains?: Array<string>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getSeriesCollection(title?: string, titleStartsWith?: string, startYear?: number, modifiedSince?: string, comics?: Array<number>, stories?: Array<number>, events?: Array<number>, creators?: Array<number>, characters?: Array<number>, seriesType?: 'collection' | 'one shot' | 'limited' | 'ongoing', contains?: Array<string>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (title !== undefined && title !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>title, 'title');
        }
        if (titleStartsWith !== undefined && titleStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>titleStartsWith, 'titleStartsWith');
        }
        if (startYear !== undefined && startYear !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>startYear, 'startYear');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (stories) {
            queryParameters = this.addToHttpParams(queryParameters,
                stories.join(COLLECTION_FORMATS['csv']), 'stories');
        }
        if (events) {
            queryParameters = this.addToHttpParams(queryParameters,
                events.join(COLLECTION_FORMATS['csv']), 'events');
        }
        if (creators) {
            queryParameters = this.addToHttpParams(queryParameters,
                creators.join(COLLECTION_FORMATS['csv']), 'creators');
        }
        if (characters) {
            queryParameters = this.addToHttpParams(queryParameters,
                characters.join(COLLECTION_FORMATS['csv']), 'characters');
        }
        if (seriesType !== undefined && seriesType !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>seriesType, 'seriesType');
        }
        if (contains) {
            queryParameters = this.addToHttpParams(queryParameters,
                contains.join(COLLECTION_FORMATS['csv']), 'contains');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/series`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches a single comic series by id.
     * This method fetches a single comic series resource.  It is the canonical URI for any comic series resource provided by the API.
     * @param seriesId Filter by series title.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSeriesIndividual(seriesId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getSeriesIndividual(seriesId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getSeriesIndividual(seriesId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getSeriesIndividual(seriesId: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (seriesId === null || seriesId === undefined) {
            throw new Error('Required parameter seriesId was null or undefined when calling getSeriesIndividual.');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/series/${encodeURIComponent(String(seriesId))}`,
            {
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of stories filtered by a series id.
     * Fetches lists of comic stories from a specific series with optional filters. See notes on individual parameters below.
     * @param seriesId The series ID.
     * @param modifiedSince Return only stories which have been modified since the specified date.
     * @param comics Return only stories contained in the specified (accepts a comma-separated list of ids).
     * @param events Return only stories which take place during the specified events (accepts a comma-separated list of ids).
     * @param creators Return only stories which feature work by the specified creators (accepts a comma-separated list of ids).
     * @param characters Return only stories which feature the specified characters (accepts a comma-separated list of ids).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSeriesStoryCollection(seriesId: number, modifiedSince?: string, comics?: Array<number>, events?: Array<number>, creators?: Array<number>, characters?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getSeriesStoryCollection(seriesId: number, modifiedSince?: string, comics?: Array<number>, events?: Array<number>, creators?: Array<number>, characters?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getSeriesStoryCollection(seriesId: number, modifiedSince?: string, comics?: Array<number>, events?: Array<number>, creators?: Array<number>, characters?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getSeriesStoryCollection(seriesId: number, modifiedSince?: string, comics?: Array<number>, events?: Array<number>, creators?: Array<number>, characters?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (seriesId === null || seriesId === undefined) {
            throw new Error('Required parameter seriesId was null or undefined when calling getSeriesStoryCollection.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (events) {
            queryParameters = this.addToHttpParams(queryParameters,
                events.join(COLLECTION_FORMATS['csv']), 'events');
        }
        if (creators) {
            queryParameters = this.addToHttpParams(queryParameters,
                creators.join(COLLECTION_FORMATS['csv']), 'creators');
        }
        if (characters) {
            queryParameters = this.addToHttpParams(queryParameters,
                characters.join(COLLECTION_FORMATS['csv']), 'characters');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/series/${encodeURIComponent(String(seriesId))}/stories`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of stories.
     * Fetches lists of comic stories with optional filters. See notes on individual parameters below.
     * @param modifiedSince Return only stories which have been modified since the specified date.
     * @param comics Return only stories contained in the specified (accepts a comma-separated list of ids).
     * @param series Return only stories contained the specified series (accepts a comma-separated list of ids).
     * @param events Return only stories which take place during the specified events (accepts a comma-separated list of ids).
     * @param creators Return only stories which feature work by the specified creators (accepts a comma-separated list of ids).
     * @param characters Return only stories which feature the specified characters (accepts a comma-separated list of ids).
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStoryCollection(modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, creators?: Array<number>, characters?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getStoryCollection(modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, creators?: Array<number>, characters?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getStoryCollection(modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, creators?: Array<number>, characters?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getStoryCollection(modifiedSince?: string, comics?: Array<number>, series?: Array<number>, events?: Array<number>, creators?: Array<number>, characters?: Array<number>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (series) {
            queryParameters = this.addToHttpParams(queryParameters,
                series.join(COLLECTION_FORMATS['csv']), 'series');
        }
        if (events) {
            queryParameters = this.addToHttpParams(queryParameters,
                events.join(COLLECTION_FORMATS['csv']), 'events');
        }
        if (creators) {
            queryParameters = this.addToHttpParams(queryParameters,
                creators.join(COLLECTION_FORMATS['csv']), 'creators');
        }
        if (characters) {
            queryParameters = this.addToHttpParams(queryParameters,
                characters.join(COLLECTION_FORMATS['csv']), 'characters');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/stories`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches a single comic story by id.
     * This method fetches a single comic story resource.  It is the canonical URI for any comic story resource provided by the API.
     * @param storyId Filter by story id.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStoryIndividual(storyId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getStoryIndividual(storyId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getStoryIndividual(storyId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getStoryIndividual(storyId: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (storyId === null || storyId === undefined) {
            throw new Error('Required parameter storyId was null or undefined when calling getStoryIndividual.');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/stories/${encodeURIComponent(String(storyId))}`,
            {
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetches lists of series filtered by a story id.
     * Fetches lists of comic series in which the specified story takes place. See notes on individual parameters below.
     * @param storyId The story ID.
     * @param events Return only series which have comics that take place during the specified events (accepts a comma-separated list of ids).
     * @param title Filter by series title.
     * @param titleStartsWith Return series with titles that begin with the specified string (e.g. Sp).
     * @param startYear Return only series matching the specified start year.
     * @param modifiedSince Return only series which have been modified since the specified date.
     * @param comics Return only series which contain the specified comics (accepts a comma-separated list of ids).
     * @param creators Return only series which feature work by the specified creators (accepts a comma-separated list of ids).
     * @param characters Return only series which feature the specified characters (accepts a comma-separated list of ids).
     * @param seriesType Filter the series by publication frequency type.
     * @param contains Return only series containing one or more comics with the specified format.
     * @param orderBy Order the result set by a field or fields. Add a \&quot;-\&quot; to the value sort in descending order. Multiple values are given priority in the order in which they are passed.
     * @param limit Limit the result set to the specified number of resources.
     * @param offset Skip the specified number of resources in the result set.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStorySeriesCollection(storyId: number, events?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, modifiedSince?: string, comics?: Array<number>, creators?: Array<number>, characters?: Array<number>, seriesType?: 'collection' | 'one shot' | 'limited' | 'ongoing', contains?: Array<string>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;
    public getStorySeriesCollection(storyId: number, events?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, modifiedSince?: string, comics?: Array<number>, creators?: Array<number>, characters?: Array<number>, seriesType?: 'collection' | 'one shot' | 'limited' | 'ongoing', contains?: Array<string>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;
    public getStorySeriesCollection(storyId: number, events?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, modifiedSince?: string, comics?: Array<number>, creators?: Array<number>, characters?: Array<number>, seriesType?: 'collection' | 'one shot' | 'limited' | 'ongoing', contains?: Array<string>, orderBy?: Array<string>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;
    public getStorySeriesCollection(storyId: number, events?: Array<number>, title?: string, titleStartsWith?: string, startYear?: number, modifiedSince?: string, comics?: Array<number>, creators?: Array<number>, characters?: Array<number>, seriesType?: 'collection' | 'one shot' | 'limited' | 'ongoing', contains?: Array<string>, orderBy?: Array<string>, limit?: number, offset?: number, observe: any = 'body', reportProgress = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {
        if (storyId === null || storyId === undefined) {
            throw new Error('Required parameter storyId was null or undefined when calling getStorySeriesCollection.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (events) {
            queryParameters = this.addToHttpParams(queryParameters,
                events.join(COLLECTION_FORMATS['csv']), 'events');
        }
        if (title !== undefined && title !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>title, 'title');
        }
        if (titleStartsWith !== undefined && titleStartsWith !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>titleStartsWith, 'titleStartsWith');
        }
        if (startYear !== undefined && startYear !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>startYear, 'startYear');
        }
        if (modifiedSince !== undefined && modifiedSince !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>modifiedSince, 'modifiedSince');
        }
        if (comics) {
            queryParameters = this.addToHttpParams(queryParameters,
                comics.join(COLLECTION_FORMATS['csv']), 'comics');
        }
        if (creators) {
            queryParameters = this.addToHttpParams(queryParameters,
                creators.join(COLLECTION_FORMATS['csv']), 'creators');
        }
        if (characters) {
            queryParameters = this.addToHttpParams(queryParameters,
                characters.join(COLLECTION_FORMATS['csv']), 'characters');
        }
        if (seriesType !== undefined && seriesType !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>seriesType, 'seriesType');
        }
        if (contains) {
            queryParameters = this.addToHttpParams(queryParameters,
                contains.join(COLLECTION_FORMATS['csv']), 'contains');
        }
        if (orderBy) {
            queryParameters = this.addToHttpParams(queryParameters,
                orderBy.join(COLLECTION_FORMATS['csv']), 'orderBy');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>offset, 'offset');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType_: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }

        return this.httpClient.get<any>(`${this.configuration.basePath}/v1/public/stories/${encodeURIComponent(String(storyId))}/series`,
            {
                params: queryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
